<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Happy Birthday — LÊ VĂN LỘC</title>
<style>
  /* Mobile-first, centered layout */
  :root{
    --bg-1: #071126; /* dark navy */
    --bg-2: #0b1722; /* charcoal-teal mix */
    --teal: #0fb3aa; /* teal accent */
    --charcoal: #1f2a30;
    --gold: #d9a441; /* warm gold */
    --muted: #97a0a6;
    --card-bg: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  body{
    background: radial-gradient(800px 500px at 10% 10%, rgba(15,179,170,0.03), transparent 10%),
                linear-gradient(180deg,var(--bg-1),var(--bg-2));
    color: #e6eef0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
  }

  .wrap{
    width:100%;
    max-width:420px;
    text-align:center;
  }

  header{
    margin-bottom:12px;
  }
  h1{
    font-size:18px;
    margin:0 0 6px;
    letter-spacing:0.6px;
    color:#f3f7f8;
  }
  p.lead{
    margin:0 0 14px;
    color:var(--muted);
    font-size:13px;
  }

  /* Canvas container */
  .canvas-wrap{
    background:var(--card-bg);
    border-radius:14px;
    padding:18px 14px;
    box-shadow:0 8px 30px rgba(2,6,23,0.6);
    margin-bottom:14px;
  }

  canvas{
    width:100%;
    height:auto;
    display:block;
    max-width:380px;
    margin:0 auto;
    touch-action:none;
  }

  /* Controls */
  .controls{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    justify-content:center;
    margin-bottom:10px;
  }
  button{
    background:linear-gradient(180deg,var(--teal),#058f86);
    color:#071126;
    border:0;
    padding:10px 12px;
    border-radius:10px;
    font-weight:700;
    font-size:14px;
    box-shadow:0 6px 16px rgba(3,10,12,0.45);
    cursor:pointer;
    min-width:120px;
  }
  button.secondary{
    background:linear-gradient(180deg,#323a3e,#22292d);
    color:#e6eef0;
    min-width:110px;
  }
  button:disabled{opacity:0.5;cursor:not-allowed;}

  /* Slider row */
  .row{
    display:flex;
    align-items:center;
    gap:10px;
    justify-content:center;
    margin:8px 0 14px;
  }
  .slider {
    -webkit-appearance: none;
    appearance:none;
    width:170px;
    height:10px;
    border-radius:10px;
    background:linear-gradient(90deg,var(--teal),var(--gold));
    outline:none;
  }
  .slider::-webkit-slider-thumb{
    -webkit-appearance:none;
    appearance:none;
    width:18px;height:18px;border-radius:50%;
    background:#fff;border:3px solid #1f2a30;
    box-shadow:0 3px 8px rgba(1,1,1,0.5);
  }

  /* Meter */
  .meter{
    width:100%;
    max-width:340px;
    margin:0 auto;
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:center;
  }
  .meter-bar{
    height:14px;
    width:220px;
    background:linear-gradient(90deg,#0e1416,#1b2426);
    border-radius:10px;
    overflow:hidden;
    box-shadow:inset 0 -4px 10px rgba(0,0,0,0.4);
  }
  .meter-fill{
    height:100%;
    width:0%;
    background:linear-gradient(90deg,var(--gold),var(--teal));
    transition:width 60ms linear;
  }
  .meter-num{
    min-width:46px;
    font-weight:700;
    font-size:13px;
    color:var(--muted);
  }

  /* Overlay when blown */
  .overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .overlay-card{
    background:linear-gradient(180deg, rgba(7,17,38,0.92), rgba(7,17,38,0.86));
    padding:22px 18px;
    border-radius:14px;
    text-align:center;
    box-shadow:0 18px 40px rgba(2,6,23,0.7);
    transform:scale(0.9);
    opacity:0;
    transition:transform 420ms cubic-bezier(.2,.9,.3,1), opacity 420ms;
  }
  .overlay.show .overlay-card{
    transform:scale(1);
    opacity:1;
    pointer-events:auto;
  }
  .overlay h2{
    margin:0;
    font-size:22px;
    letter-spacing:2px;
    color:var(--gold);
  }
  .overlay p{
    margin:8px 0 0;
    font-size:16px;
    color:#f3f7f8;
    font-weight:700;
  }

  /* Make sure overlay fits in small screens */
  .canvas-wrap{position:relative;}
  @media(min-width:420px){
    .controls{gap:12px}
  }
</style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <h1>Make a wish — blow to extinguish</h1>
      <p class="lead">One candle, microphone detection, and a short synthesized song. Tap "Enable mic" to start.</p>
    </header>

    <div class="canvas-wrap" id="canvasCard">
      <!-- Canvas for the emoji-like cake -->
      <canvas id="cakeCanvas" width="760" height="760" aria-label="Birthday cake illustration"></canvas>

      <!-- Celebration overlay (hidden until blow-out) -->
      <div class="overlay" id="overlay" aria-hidden="true">
        <div class="overlay-card" id="overlayCard" role="status" aria-live="polite">
          <h2>HAPPY BIRTHDAY</h2>
          <p>LÊ VĂN LỘC</p>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="controls" aria-hidden="false">
      <button id="enableMicBtn">Enable mic</button>
      <button id="relightBtn" class="secondary" disabled>Relight candle</button>
    </div>

    <!-- Sensitivity and meter -->
    <div class="row" style="justify-content:space-around;max-width:340px;margin:0 auto;">
      <label style="font-size:13px;color:var(--muted);min-width:76px;text-align:left;">Sensitivity</label>
      <input id="sensitivity" class="slider" type="range" min="10" max="70" value="40" aria-label="sensitivity slider"/>
      <div style="min-width:36px;font-weight:700;color:var(--muted);text-align:right;font-size:13px;" id="sVal">40</div>
    </div>

    <div class="meter" style="margin-top:6px;">
      <div class="meter-bar" aria-hidden="true">
        <div class="meter-fill" id="meterFill"></div>
      </div>
      <div class="meter-num" id="meterNum">0</div>
    </div>

    <p style="font-size:12px;color:var(--muted);margin-top:12px;">Tip: move phone near mouth and blow — adjust sensitivity if it doesn't trigger.</p>
  </div>

<script>
/*
  index.html
  Single-file GitHub Pages project that:
  - Draws a simple emoji-like birthday cake (Canvas) with one candle.
  - Uses getUserMedia() + Web Audio API to measure microphone volume (RMS).
  - Detects blowing when RMS exceeds threshold for a short duration -> extinguish flame.
  - Plays synthesized "Happy Birthday" melody (Oscillator + Gain) after blow-out.
  - UI: Enable mic, Relight candle, sensitivity slider (10-70), live volume meter + numeric display.
  - Shows an overlay message when blown: "HAPPY BIRTHDAY" / "LÊ VĂN LỘC".
  - Mobile-first, robust with comments.
*/

/* -------------------------
   Visual / Canvas Drawing
   ------------------------- */
const canvas = document.getElementById('cakeCanvas');
const ctx = canvas.getContext('2d', {alpha: true});

/* Use an internal resolution that's comfortably large and scales on CSS width */
function resizeCanvas() {
  // Keep square canvas; width from CSS
  const displayWidth = Math.min(760, Math.floor(document.querySelector('.canvas-wrap').clientWidth * 2));
  canvas.width = displayWidth;
  canvas.height = displayWidth;
  drawCake();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* State */
let candleLit = true;

/* Colors (masculine palette) */
const colors = {
  background: '#071126',
  cakePrimary: '#0f6060', // teal-dark
  cakeSecondary: '#153042', // charcoal
  icing: '#0fb3aa', // teal accent for a subtle glow
  plate: '#1f2a30',
  candle: '#d9a441', // warm gold
  wick: '#2b2b2b',
  flameInner: '#fff1b8',
  flameOuter: '#ffb84d',
  shadow: 'rgba(2,6,23,0.6)'
};

/* Draw a simple emoji-like cake with one candle */
function drawCake() {
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // Background subtle radial vignette
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, '#071126');
  g.addColorStop(1, '#04101a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);

  // Center coordinates
  const cx = w/2;
  const cy = h/2 + h*0.06;

  // Draw plate
  const plateW = w*0.6;
  const plateH = h*0.08;
  roundRect(ctx, cx-plateW/2, cy + h*0.22, plateW, plateH, plateH/2, colors.plate);
  ctx.shadowColor = colors.shadow;
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 6;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Cake base (two layers)
  const cakeW = w*0.48;
  const cakeH1 = h*0.16;
  const cakeH2 = h*0.14;
  // Bottom layer
  roundRect(ctx, cx - cakeW/2, cy - cakeH2/2 + cakeH1*0.2, cakeW, cakeH2, 18, colors.cakeSecondary);
  // Slight inner shine
  const shine = ctx.createLinearGradient(0, cy - cakeH2/2, 0, cy + cakeH2/2);
  shine.addColorStop(0, 'rgba(255,255,255,0.04)');
  shine.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = shine;
  ctx.fill();

  // Upper layer
  roundRect(ctx, cx - cakeW*0.78/2, cy - cakeH1 - cakeH2*0.1, cakeW*0.78, cakeH1, 14, colors.cakePrimary);
  // Icing (rounded drips simplified)
  const icingH = 14;
  ctx.fillStyle = colors.icing;
  ctx.beginPath();
  const ix = cx - (cakeW*0.78)/2;
  const iw = cakeW*0.78;
  const iy = cy - cakeH1 - cakeH2*0.1;
  ctx.moveTo(ix, iy + icingH/2);
  // make a few semicircular drips across
  const dripCount = 5;
  for (let i=0;i<=dripCount;i++){
    const px = ix + (i/dripCount)*iw;
    const py = iy + icingH/2 + Math.sin(i*1.3)*6; // slight variation
    ctx.quadraticCurveTo(px - iw/dripCount/2, py - 12, px, iy + icingH/2);
  }
  ctx.lineTo(ix+iw, iy+icingH);
  ctx.lineTo(ix+iw, iy);
  ctx.lineTo(ix, iy);
  ctx.closePath();
  ctx.fill();
  // small highlight
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(ix + iw*0.08, iy + 4, iw*0.5, 6);
  ctx.globalAlpha = 1;

  // Candle stem (centered)
  const candleH = h*0.16;
  const candleW = w*0.04;
  const candleX = cx - candleW/2;
  const candleY = iy - candleH + 8;
  // stem
  roundRect(ctx, candleX, candleY, candleW, candleH, 8, colors.candle);
  // candle stripes for a bit of visual interest
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let i=0;i<3;i++){
    ctx.fillRect(candleX + candleW*0.14, candleY + i*(candleH/3)+6, candleW*0.7, 4);
  }
  // wick
  ctx.fillStyle = colors.wick;
  ctx.fillRect(cx - 1.5, candleY - 8, 3, 8);

  // Flame (if lit)
  if (candleLit) {
    drawFlame(ctx, cx, candleY - 14, Math.max(10, w*0.02));
  }

  // Tiny shadow under cake
  const shadowGrad = ctx.createRadialGradient(cx, cy + cakeH2*0.9, 10, cx, cy + cakeH2*0.9, plateW*0.7);
  shadowGrad.addColorStop(0, 'rgba(0,0,0,0.35)');
  shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(cx, cy + cakeH2 + 12, cakeW*0.45, plateH*0.4, 0, 0, Math.PI*2);
  ctx.fill();

  // Simple smiling face on cake to be "emoji-like"
  const eyeY = iy + cakeH1*0.35;
  const eyeXOffset = 28;
  ctx.fillStyle = "#071126";
  ctx.beginPath();
  ctx.ellipse(cx - eyeXOffset, eyeY, 6, 8, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx + eyeXOffset, eyeY, 6, 8, 0, 0, Math.PI*2);
  ctx.fill();
  // smile
  ctx.strokeStyle = "#071126";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx, iy + cakeH1*0.6, 26, 0.15*Math.PI, 0.85*Math.PI);
  ctx.stroke();
}

/* Helper: rounded rectangle draw (path + fill) */
function roundRect(ctx, x, y, w, h, r, fillStyle) {
  ctx.beginPath();
  const radius = Math.min(r, w/2, h/2);
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + w, y, x + w, y + h, radius);
  ctx.arcTo(x + w, y + h, x, y + h, radius);
  ctx.arcTo(x, y + h, x, y, radius);
  ctx.arcTo(x, y, x + w, y, radius);
  ctx.closePath();
  ctx.fillStyle = fillStyle || '#000';
  ctx.fill();
}

/* Draw stylized flame */
function drawFlame(ctx, x, y, size) {
  // outer flame
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(Math.PI * -0.03);
  const grad = ctx.createRadialGradient(0, -size*0.18, size*0.1, 0, 0, size*1.2);
  grad.addColorStop(0, colors.flameInner);
  grad.addColorStop(0.6, colors.flameOuter);
  grad.addColorStop(1, 'rgba(255,120,40,0.06)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(0, -size*1.2);
  ctx.bezierCurveTo(size*0.8, -size*0.6, size*0.2, size*0.8, 0, size*0.9);
  ctx.bezierCurveTo(-size*0.2, size*0.8, -size*0.8, -size*0.6, 0, -size*1.2);
  ctx.closePath();
  ctx.fill();

  // inner bright core
  ctx.fillStyle = colors.flameInner;
  ctx.beginPath();
  ctx.moveTo(0, -size*0.9);
  ctx.bezierCurveTo(size*0.35, -size*0.45, size*0.1, size*0.5, 0, size*0.56);
  ctx.bezierCurveTo(-size*0.1, size*0.5, -size*0.35, -size*0.45, 0, -size*0.9);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

/* -------------------------
   Audio / Microphone Setup
   ------------------------- */
let audioCtx = null;
let analyser = null;
let mediaStream = null;
let rafId = null;
let dataArray = null;

/* UI elements */
const enableBtn = document.getElementById('enableMicBtn');
const relightBtn = document.getElementById('relightBtn');
const sensitivityInput = document.getElementById('sensitivity');
const sVal = document.getElementById('sVal');
const meterFill = document.getElementById('meterFill');
const meterNum = document.getElementById('meterNum');
const overlay = document.getElementById('overlay');
const overlayCard = document.getElementById('overlayCard');

/* Sensitivity initial */
sVal.textContent = sensitivityInput.value;

/* Map slider value (10-70) to RMS threshold: higher slider => more sensitive (lower threshold)
   threshold = (80 - s) * 0.001 -> s=70 => 0.01 (sensitive); s=10 => 0.07 (less sensitive)
*/
function sliderToThreshold(s) {
  return (80 - s) * 0.001;
}

/* Blowing detection state */
let blowCounter = 0;
const requiredFrames = 8; // frames above threshold (~8 frames at 60fps => ~130ms)
let lastRms = 0;

/* When user presses "Enable mic" */
enableBtn.addEventListener('click', async () => {
  // Create AudioContext on user gesture to satisfy autoplay policies
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (err) {
      alert('Web Audio API is not supported in this browser.');
      return;
    }
  }

  // Resume audio context (some browsers require resume on gesture)
  try {
    await audioCtx.resume();
  } catch (e) {
    // ignore
  }

  // Request microphone
  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
  } catch (err) {
    alert('Microphone access denied or not available.');
    return;
  }

  // Create analyser and connect
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  const source = audioCtx.createMediaStreamSource(mediaStream);
  source.connect(analyser);

  dataArray = new Uint8Array(analyser.fftSize);

  enableBtn.disabled = true;
  enableBtn.textContent = 'Mic enabled';
  relightBtn.disabled = false;

  // Play a tiny silent sound to fully unlock audio on some browsers (safe since user gesture)
  unlockAudio();

  // Start monitoring loop
  monitorAudio();
});

/* Unlock audio by scheduling a tiny silent buffer */
function unlockAudio() {
  try {
    const buffer = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    const g = audioCtx.createGain();
    g.gain.value = 0;
    src.connect(g).connect(audioCtx.destination);
    src.start(0);
  } catch (e) {
    // ignore
  }
}

/* Monitor microphone volume using analyser time-domain data */
function monitorAudio() {
  if (!analyser) return;

  function update() {
    analyser.getByteTimeDomainData(dataArray);
    // compute RMS from time-domain data (normalized -1..1)
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] - 128) / 128;
      sum += v * v;
    }
    const rms = Math.sqrt(sum / dataArray.length);
    lastRms = rms;

    // Update meter (scale to 0-100 using a reasonable cap)
    const cap = 0.08; // value where meter reads 100%
    const pct = Math.min(1, rms / cap);
    meterFill.style.width = (pct * 100) + '%';
    meterNum.textContent = String(Math.round(pct * 100));

    // Blow detection: check if RMS > threshold for a short time
    const threshold = sliderToThreshold(Number(sensitivityInput.value));
    if (rms > threshold) {
      blowCounter++;
      if (blowCounter >= requiredFrames && candleLit) {
        // Detected a blow
        extinguishCandle();
      }
    } else {
      blowCounter = 0;
    }

    // Continue
    rafId = requestAnimationFrame(update);
  }

  // Start immediately
  update();
}

/* -------------------------
   Extinguish & Melody
   ------------------------- */
function extinguishCandle() {
  candleLit = false;
  drawCake();

  // Stop monitoring briefly to avoid retriggering while playing
  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = null;
  }

  // Show overlay with animation
  overlay.classList.add('show');
  overlay.setAttribute('aria-hidden', 'false');

  // Play synthesized "Happy Birthday" melody
  try {
    playHappyBirthday();
  } catch (e) {
    console.warn('Could not play melody:', e);
  }

  // After playing, continue monitoring (short delay to avoid immediate retrigger)
  setTimeout(() => {
    if (analyser && !rafId) monitorAudio();
  }, 1200);
}

/* Relight candle (manual) */
relightBtn.addEventListener('click', () => {
  candleLit = true;
  drawCake();
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden', 'true');
});

/* -------------------------
   Synthesis: Happy Birthday
   ------------------------- */

/* Utility: map note name to frequency (A4 = 440Hz) */
function noteToFreq(note) {
  // note like "C4", "G#4", "Bb3"
  const noteRegex = /^([A-G])([#b]?)(\d)$/;
  const m = noteRegex.exec(note);
  if (!m) return 440;
  const pitchClass = m[1];
  const accidental = m[2];
  const octave = parseInt(m[3], 10);
  const semisFromA4 = {
    'C': -9, 'D': -7, 'E': -5, 'F': -4, 'G': -2, 'A': 0, 'B': 2
  }[pitchClass];
  let semitone = semisFromA4;
  if (accidental === '#') semitone++;
  if (accidental === 'b') semitone--;
  // adjust for octave
  semitone += (octave - 4) * 12;
  return 440 * Math.pow(2, semitone / 12);
}

/* Melody data: Happy Birthday in C major (one verse).
   Each entry: [note, durationInBeats], where beat length controlled by tempo.
*/
const melody = [
  ['G4', 1], ['G4', 1], ['A4', 2], ['G4', 2], ['C5', 2], ['B4', 4],
  ['G4', 1], ['G4', 1], ['A4', 2], ['G4', 2], ['D5', 2], ['C5', 4],
  // short bridge
  ['G4', 1], ['G4', 1], ['G5', 2], ['E5', 2], ['C5', 2], ['B4', 2], ['A4', 4],
  ['F5', 1], ['F5', 1], ['E5', 2], ['C5', 2], ['D5', 2], ['C5', 4]
];

/* Play melody using Oscillator + Gain notes scheduling */
function playHappyBirthday() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const tempo = 160; // beats per minute (faster-ish for short pleasant)
  const beatTime = 60 / tempo; // seconds per beat

  const masterGain = audioCtx.createGain();
  masterGain.gain.setValueAtTime(0.001, now);
  masterGain.connect(audioCtx.destination);

  // small fade-in
  masterGain.gain.linearRampToValueAtTime(0.9, now + 0.02);

  let t = now + 0.02;
  melody.forEach(([note, beats], idx) => {
    const duration = beats * beatTime;
    // Use two oscillators slightly detuned for warmth
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const freq = noteToFreq(note);
    osc1.type = 'sine';
    osc2.type = 'triangle';
    osc1.frequency.setValueAtTime(freq, t);
    osc2.frequency.setValueAtTime(freq * 1.0025, t); // slight detune
    // envelope
    g.gain.setValueAtTime(0.0, t);
    g.gain.linearRampToValueAtTime(0.8, t + 0.01);
    g.gain.linearRampToValueAtTime(0.6, t + duration*0.6);
    g.gain.exponentialRampToValueAtTime(0.001, t + duration - 0.02);

    osc1.connect(g);
    osc2.connect(g);
    g.connect(masterGain);

    osc1.start(t);
    osc2.start(t);
    osc1.stop(t + duration);
    osc2.stop(t + duration);

    t += duration + (beatTime * 0.06); // tiny gap between notes
  });

  // master fade-out at end
  masterGain.gain.setValueAtTime(0.001, t + 0.05);
  // disconnect after finished
  setTimeout(()=> {
    try { masterGain.disconnect(); } catch(e){}
  }, (t - now + 0.2) * 1000);
}

/* -------------------------
   UI: slider updates and accessibility
   ------------------------- */
sensitivityInput.addEventListener('input', () => {
  sVal.textContent = sensitivityInput.value;
});

/* Accessibility: keyboard toggling for canvas - tapping canvas toggles relight if blown */
canvas.addEventListener('click', () => {
  // If already blown, clicking relights
  if (!candleLit) {
    candleLit = true;
    overlay.classList.remove('show');
    overlay.setAttribute('aria-hidden', 'true');
    drawCake();
  }
});

/* Draw initially */
drawCake();

/* Clean up on page hide */
window.addEventListener('pagehide', () => {
  if (rafId) cancelAnimationFrame(rafId);
  if (mediaStream) {
    mediaStream.getTracks().forEach(t => t.stop());
  }
  if (audioCtx && audioCtx.close) audioCtx.close();
});
</script>
</body>
</html>
